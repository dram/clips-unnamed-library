;;;
;;; BEGIN OF DATA TEMPLATE DEFINIATIONS
;;;

(deftemplate function
  (slot name (type SYMBOL))
  (multislot depends-on (type SYMBOL)))

(deftemplate has-dependent
  (slot name (type SYMBOL))
  (slot dependent (type SYMBOL)))

(deftemplate source
  (slot name (type SYMBOL))
  (slot content (type STRING)))

;;; END OF DATA TEMPLATES

;;;
;;; BEGIN OF DATA DEFINIATIONS
;;;

(defglobal ?*function-list* = (create$))

;;; END OF DATA

;;;
;;; BEGIN OF RULE DEFINIATIONS
;;;

(defrule start
 =>
  (foreach
      ?name ?*requested-functions*
    (assert (requested-function ?name))))

(defrule process-requested-functions
  (requested-function ?name)
 =>
  (bind ?filename (format nil "sources/%s.clp" ?name))
  (bind ?source "")
  (bind ?dependences (create$))

  (open ?filename file)
  (while (neq (bind ?line (readline file)) EOF)
    (bind ?source
      (format nil
              "%s%s%n"
              ?source
              (UNNAMED::replace-substring ?line "UNNAMED::" "")))

    (bind ?substring ?line)
    (while (neq "" ?substring)
      (if (bind ?i (str-index "UNNAMED::" ?substring))
       then (bind ?substring (sub-string (+ ?i (str-length "UNNAMED::"))
                                         (str-length ?substring)
                                         ?substring))
            (bind ?j (UNNAMED::index-substrings ?substring (create$ " " ")")))
            (if ?j
             then (bind ?j (- ?j 1))
             else (bind ?j (str-length ?substring)))
            (bind ?dependences
              ?dependences (string-to-field (sub-string 1 ?j ?substring)))
       else (bind ?substring "")))

    (bind ?substring ?line)
    (while (neq "" ?substring)
      (if (bind ?i (str-index "UNNAMED-" ?substring))
       then (bind ?substring (sub-string (+ ?i (str-length "UNNAMED-"))
                                         (str-length ?substring)
                                         ?substring))
            (bind ?j (UNNAMED::index-substrings ?substring (create$ " " ")")))
            (if ?j
             then (bind ?j (- ?j 1))
             else (bind ?j (str-length ?substring)))
            (assert (requested-c-function
                     (string-to-field (sub-string 1 ?j ?substring))))
       else (bind ?substring ""))))
  (close file)
  (bind ?dependences (UNNAMED::delete-duplicates$ ?dependences))

  (assert (source (name ?name) (content ?source)))
  (assert (function (name ?name) (depends-on ?dependences)))

  (if (UNNAMED::emptyp ?dependences)
   then (assert (dependence-satisfied ?name))
   else (foreach
            ?dependence ?dependences
          (assert
            (requested-function ?dependence)
            (has-dependent (name ?dependence) (dependent ?name))))))

(defrule process-requested-c-functions
  (requested-c-function ?name)
 =>
  (bind ?filename (format nil "sources/%s.c" ?name))
  (bind ?source "")
  (bind ?meta-source "")

  (open ?filename file)
  (while (neq (bind ?line (readline file)) EOF)

    (if (bind ?i (str-index "//META/" ?line))
     then (bind ?meta-line (sub-string (+ ?i (str-length "//META/"))
                                       (str-length ?line)
                                       ?line))
          (bind ?meta-source (format nil "%s%s%n" ?meta-source ?meta-line))
     else
       (bind ?source (format nil "%s%s%n" ?source ?line))))
  (close file)

  (assert (c-source ?source))
  (assert (c-meta-source ?meta-source)))

;;; Kahn's algorithm for topological sorting
;;; See: https://en.wikipedia.org/wiki/Topological_sorting
(defrule sort-functions
  (declare (salience -5010)) ; run after requested-function processing
  (dependence-satisfied ?name)
 =>
  (bind ?*function-list* ?*function-list* ?name))

(defrule sort-function-dependents
  (declare (salience -5020))
  (dependence-satisfied ?name)
  (has-dependent (name ?name) (dependent ?dependent))
  (function (name ?dependent) (depends-on $?dependent-dependences))
 =>
  (if (subsetp ?dependent-dependences ?*function-list*)
   then (assert (dependence-satisfied ?dependent))))

(defrule output-source-code
  (declare (salience -10000)) ; run after function list sorting
 =>
  (open (str-cat ?*output-path* / unnamed.clp) output "w")

  (printout output
            ";;; Generated by clips-unnamed-library:" crlf
            ";;;     compile-library " ?*output-path*)
  (foreach ?argument ?*requested-functions* (printout output " " ?argument))
  (printout output crlf)

  (foreach
      ?name (UNNAMED::delete-duplicates$ ?*function-list*)
    (format output "%n;;; BEGIN DEFINITION of %s%n%n" ?name)
    (do-for-fact ((?f source)) (eq ?f:name ?name)
      (printout output ?f:content))
    (format output "%n;;; END of %s%n%n" ?name))
  (close output))

(defrule output-c-source-code
  (declare (salience -10000)) ; run after function list sorting
  (exists (c-source ?) (c-meta-source ?))
 =>
  (open (str-cat ?*output-path* / unnamed.c) output "w")

  (printout output "/// Generated by clips-unnamed-library" crlf crlf)

  (printout output "#include \"clips/clips.h\"" crlf crlf)

  (do-for-all-facts ((?f c-source))
      (printout output (nth$ 1 ?f:implied) crlf))

  (printout output "void UserFunctions(Environment *env)" crlf "{" crlf)
  (do-for-all-facts ((?f c-meta-source))
      (printout output (nth$ 1 ?f:implied) crlf))
  (printout output "}" crlf)

  (close output))

;;; END OF RULES

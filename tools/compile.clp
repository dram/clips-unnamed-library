;;;
;;; BEGIN OF DATA TEMPLATE DEFINIATIONS
;;;

(deftemplate function
  (slot name (type SYMBOL))
  (multislot depends-on (type SYMBOL)))

(deftemplate has-dependent
  (slot name (type SYMBOL))
  (slot dependent (type SYMBOL)))

;;; END OF DATA TEMPLATES

;;;
;;; BEGIN OF DATA DEFINIATIONS
;;;

(defglobal ?*function-list* = (create$))

;;; END OF DATA

;;;
;;; BEGIN OF RULE DEFINIATIONS
;;;

(defrule start
 =>
  (load-facts ?*function-facts-file*)
  (foreach
      ?name ?*requested-functions*
    (assert (requested-function ?name))))

(defrule process-requested-functions
  (requested-function ?name)
  (function (name ?name) (depends-on $?dependences))
 =>
  (if (UNNAMED::empty$ ?dependences)
   then (assert (dependence-satisfied ?name))
   else (foreach
            ?dependence ?dependences
          (assert
            (requested-function ?dependence)
            (has-dependent (name ?dependence) (dependent ?name))))))

;;; Kahn's algorithm for topological sorting
;;; See: https://en.wikipedia.org/wiki/Topological_sorting
(defrule sort-functions
  (declare (salience -5010)) ; run after requested-function processing
  (dependence-satisfied ?name)
 =>
  (bind ?*function-list* ?*function-list* ?name))

(defrule sort-function-dependents
  (declare (salience -5020))
  (dependence-satisfied ?name)
  (has-dependent (name ?name) (dependent ?dependent))
  (function (name ?dependent) (depends-on $?dependent-dependences))
 =>
  (if (subsetp ?dependent-dependences ?*function-list*)
   then (assert (dependence-satisfied ?dependent))))

(defrule output-source-code
  (declare (salience -10000)) ; run after function list sorting
 =>
  (open ?*output-file-path* output "w")

  (format output
          ";;; Generated by clips-unnamed-library: compile-library %s"
          ?*output-file-path*)
  (foreach ?argument ?*requested-functions* (printout output " " ?argument))
  (printout output crlf)

  (foreach
      ?name (UNNAMED::delete-duplicates$ ?*function-list*)
    (bind ?filename (format nil "sources/%s.clp" ?name))
    (format output "%n;;; BEGIN DEFINITION of %s%n%n" ?name)
    (open ?filename file)
    (while (neq (bind ?line (readline file)) EOF)
      (format output "%s%n" (UNNAMED::replace-substring ?line "UNNAMED::" "")))
    (close file)
    (format output "%n;;; END of %s%n%n" ?name))
  (close output))

;;; END OF RULES
